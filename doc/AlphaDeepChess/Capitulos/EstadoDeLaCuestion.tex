\chapter{State of the art}
\label{cap:estadoDeLaCuestion}

\section{Board representation}

The chessboard is where the game takes place and which serves as the foundation for all operations. In order to store a position setting with its pieces and other additional information like the side to move\footnote{Corresponds to the colour that has the turn of movement.}, the castling rights\footnote{Refers to the possibilities for each side to castle both short and long. Castling is explained in~\ref{sec:castling}.} or the fifty-move rule counter\footnote{This rule is explained in~\ref{itm:fifty-move-rule}.}, we can encounter different types of representations: piece centric, square centric and hybrid solutions. We chose to use bitboards as the primary representation, complemented by a piece list to store the piece on each square (piece centric representation). Additionally, the game state is stored in a bit field.

\vspace{1em}

A \textbf{bitboard\footnote{\url{https://www.chessprogramming.org/Bitboards}}}, also known as a bitset or bitmap, is a 64-bit word structure that efficiently represents a chessboard because it matches with the number of squares: every bit corresponds to a square of the chessboard.

\vspace{1em}

A \textbf{bit field}, in constrast to a bitboard, uses a fixed number of bits within an integer to store multiple small values or flags.

\vspace{1em}

For example, using a 64-bit bitfield, we can allocate 6 bits to store the number of pieces on the board, as $2^6 = 64$ possibilities. This means the bits would occupy an interval from $X$ included to $X+5$.

\vspace{1em}

For more information about board representation, refer to the Chess Programming page: \url{https://www.chessprogramming.org/Board_Representation}.

\section{Move generation}

An essential part of any chess engine is move generation. It involves generating all possible legal moves from a given position ensuring chess rules.

\vspace{1em}

There are two types of move generation:

\begin{itemize}
    \item \textbf{Pseudolegal move generation}: generates all moves without considering whether the king is left in check after the move. It requires additional filtering to remove illegal moves.
    \item \textbf{Legal move generation}: generates only moves that are valid according to the chess rules, ensuring that the king is not left in check. The more accurate, the computationally more expensive it is.
\end{itemize}

We have preferred to use \textbf{legal move generation}. Although it is computationally more expensive than pseudolegal move generation, it simplifies the filtering process and ensures that the generated moves are correct.

Additionally, we have chosen to implement \textbf{magic bitboards} for this type of move generator, particularly for sliding pieces such as rooks, bishops, and queens. Magic bitboards use precomputed attack tables and bitwise operations. This approach significantly reduces the computational cost of move generation, enabling the engine to explore deeper levels of the game tree while maintaining accuracy and performance.

For more information about move generation, refer to the Chess Programming page: \url{https://www.chessprogramming.org/Move_Generation}.

\section{Game trees}

Sequential games, such as chess or tic-tac-toe, where players take turns alternately, unlike simultaneous games, can be represented in a game tree or graph. In this representation, the root node is the main position from which we look for the best move, and each subsequent node is a possible option or game state, forming a tree-like structure. This tree has a height or depth that refers to the number of levels or layers in the tree, starting from the root node (the initial game state) and extending to the leaf nodes.

\vspace{1em}

The depth of a chess game tree is important because it determines the extent to which it will be analysed and evaluated. A depth of 1 represents all possible moves for the current player or side to move, while a depth of 2 includes the opponent's responses to those moves. As the depth increases, the tree grows exponentially, making it computationally expensive to explore all possible states.

\section{Search algorithms}

There are different approaches to find the best move from a position. Some of these search algorithms are: Depth-First Search (DFS)\footnote{\url{https://www.chessprogramming.org/Depth-First}}, Best-First Search\footnote{\url{https://www.chessprogramming.org/Best-First}} (not to be confused with Breadth-First Search or BFS) and Parallel Search\footnote{\url{https://www.chessprogramming.org/Parallel_Search}}.

\paragraph{Depth-First Search} refers to the process of exploring each branch of a tree or graph to its deepest level before backtracking\footnote{\url{https://en.wikipedia.org/wiki/Backtracking}}.

\paragraph{Best-First Search} refers to the way of exploring the most promising nodes first. They typically require significant memory resources, as they must store a search space\footnote{Represents the collection of all potential solutions in search algorithms.} that grows exponentially.

\paragraph{Parallel Search} refers to mulithreaded search, a technique used to accelerate search processes by leveraging multiple processors. The downside part is that by utilizing these additional processors effectively poses unique challenges, as searchtree traversal is inherently sequential.

\vspace{1em}

% Comparar entre ellas y escribir la causa de haber elegido depth-first search
Let's visualize each of the search algorithms with their advantages and disadvantages:

\begin{table}[H]
\centering
\begin{tabular}{|p{3.5cm}|p{4.5cm}|p{4.5cm}|}
\hline
\textbf{Algorithm} & \textbf{Advantages} & \textbf{Disadvantages} \\ \hline
\textbf{Depth-First Search (DFS)} 
& 
- Memory-efficient: it does not store the entire search space. \newline 
- Simple to implement and compatible with alpha-beta pruning. 
& 
- May explore less promising branches before finding optimal solutions.
\newline
- Sequential dependency: it is not easy to parallelize. \\ \hline

\textbf{Best-First Search} 
& 
- Explores the most promising nodes first, potentially finding solutions faster. 
& 
- Requires significant memory to store the search space, which grows exponentially. \newline \\ \hline

\textbf{Parallel Search} 
& 
- Accelerates search by taking advantage of multiple processors. \newline 
- Effective for modern multiprocessor systems. 
& 
- Challenging to manage synchronization and resource utilization. \newline 
- Limited scalability due to the inherently sequential nature of search tree traversal. \\ \hline
\end{tabular}
\caption{Comparison of search algorithms.}
\label{tab:search-algorithms}
\end{table}

Based on this comparison, we selected Depth-First Search for its simplicity, low memory requirements, and compatibility with alpha-beta pruning.

\subsection{Minimax algorithm}

The \textbf{minimax}\footnote{\url{https://www.chessprogramming.org/Minimax}} algorithm is a decision making algorithm that follows DFS principles. It is based on the assumption that both players play optimally, with one player (the maximizer) trying to maximize his score and the other player (the minimizer) trying to minimize his score. It explores the game tree to evaluate all possible moves and determines the best move for the current player.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        level distance=1.5cm,
        level 1/.style={sibling distance=4cm},
        level 2/.style={sibling distance=2cm},
        circleNode/.style={circle, draw, minimum size=1cm, inner sep=0pt},
        squareNode/.style={rectangle, draw, minimum size=1cm, inner sep=0pt}
    ]
        % Root node
        \node[squareNode] (root) {3}
            child {node[circleNode] (b) {3}
                child {node[squareNode] (d) {3}}
                child {node[squareNode] (e) {5}}
            }
            child {node[circleNode] (c) {2}
                child {node[squareNode] (f) {2}}
                child {node[squareNode] (g) {9}}
            };

        \node[left=1.2cm] at (root) {\textbf{MAX}};
        \node[left=1.2cm] at (b) {\textbf{MIN}};
        \node[left=1.2cm] at (d) {\textbf{MAX}};

        % Edges
        \draw[-{Stealth}, draw=red] (b) -- (root);
        \draw[-] (root) -- (c);
        \draw[-{Stealth}, draw=red] (d) -- (b);
        \draw[-] (b) -- (e);
        \draw[-{Stealth}, draw=red] (f) -- (c);
        \draw[-] (c) -- (g);
    \end{tikzpicture}
    \caption{Example of minimax.}
    \label{fig:minimax}
\end{figure}

In this example\footnote{Note that this example is a binary tree, but there could be more moves or nodes in a real scenario.}, white is represented by square nodes and black by circle nodes. Each of them wants to maximize or minimize their respective final value in each position. For the leftmost pair of leaf nodes with values of 3 and 5, 3 is chosen because black tries to get the lowest score between them. Then, the other pair of leaf nodes with values of 2 and 9, 2 is chosen for the same reason. Lastly, at the root node, white selects 3 as the maximum number between 3 and 2.

\paragraph{Negamax} is a variant of minimax that simplifies the implementation by assuming that the gain of one player is the loss of the other. This allows the use of a single evaluation function with inverted values. In this project, this variant is not used.

\paragraph{Alpha-beta pruning}\footnote{\url{https://www.chessprogramming.org/Alpha-Beta}} is an optimization of minimax that reduces significantly the number of evaluated nodes in the game tree. It uses two values, alpha and beta, to discard branches that cannot influence the final decision improving the efficiency.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        level distance=1.5cm,
        level 1/.style={sibling distance=4cm},
        level 2/.style={sibling distance=2cm},
        circleNode/.style={circle, draw, minimum size=1cm, inner sep=0pt},
        squareNode/.style={rectangle, draw, minimum size=1cm, inner sep=0pt}
    ]
        % Root node
        \node[squareNode] (root) {3}
            child {node[circleNode] (b) {3}
                child {node[squareNode] (d) {3}}
                child {node[squareNode] (e) {5}}
            }
            child {node[circleNode] (c) {2}
                child {node[squareNode] (f) {2}}
                child {node[squareNode, dashed, red] (g) {X}}
            };

        \node[left=1.2cm] at (root) {\textbf{MAX}};
        \node[left=1.2cm] at (b) {\textbf{MIN}};
        \node[left=1.2cm] at (d) {\textbf{MAX}};

        % Edges
        \draw[-{Stealth}, draw=red] (b) -- (root);
        \draw[-] (root) -- (c);
        \draw[-{Stealth}, draw=red] (d) -- (b);
        \draw[-] (b) -- (e);
        \draw[-{Stealth}, draw=red] (f) -- (c);
        \draw[-] (c) -- (g);
    \end{tikzpicture}
    \caption{Example of alpha-beta pruning.}
    \label{fig:alpha-beta-pruning}
\end{figure}

In this other example, the red dashed node is pruned because it cannot influence the final decision independently of its value. If its value is less than or equal to 2, it will never improve the previously analyzed value of 3. On the other hand, if its value is greater than 2, black will still choose 2 to minimize the score.

\vspace{1em}

Another formal explain this is by using $alpha$ and $beta$ values:

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        level distance=1.5cm,
        level 1/.style={sibling distance=4cm},
        level 2/.style={sibling distance=2cm},
        circleNode/.style={circle, draw, minimum size=1cm, inner sep=0pt},
        squareNode/.style={rectangle, draw, minimum size=1cm, inner sep=0pt}
    ]
        % Root node
        \node[squareNode] (root) {}
            child {node[circleNode] (b) {}
                child {node[squareNode] (d) {3}}
                child {node[squareNode] (e) {5}}
            }
            child {node[circleNode] (c) {}
                child {node[squareNode] (f) {2}}
                child {node[squareNode] (g) {1}}
            };

        % Labels for alpha and beta
        \node[right=0.7cm, align=left] at (root) {$\alpha = -\infty$ \\ $\beta = +\infty$};
        \node[right=0.7cm, align=left] at (b) {$\alpha = -\infty$ \\ $\beta = +\infty$};

        % Node labels
        \node[left=0.7cm] at (root) {\textbf{MAX}};
        \node[left=0.7cm] at (b) {\textbf{MIN}};
        \node[left=0.7cm] at (d) {\textbf{MAX}};

        % Edges
        \draw[-, draw=red] (root) -- (b);
        \draw[-] (root) -- (c);
        \draw[-, draw=red] (b) -- (d);
        \draw[-] (b) -- (e);
        \draw[-] (c) -- (f);
        \draw[-] (c) -- (g);
    \end{tikzpicture}

    \hspace{3em}

    \centering
    \begin{tikzpicture}[
        level distance=1.5cm,
        level 1/.style={sibling distance=4cm},
        level 2/.style={sibling distance=2cm},
        circleNode/.style={circle, draw, minimum size=1cm, inner sep=0pt},
        squareNode/.style={rectangle, draw, minimum size=1cm, inner sep=0pt}
    ]
        % Root node
        \node[squareNode] (root) {}
            child {node[circleNode] (b) {}
                child {node[squareNode] (d) {3}}
                child {node[squareNode] (e) {5}}
            }
            child {node[circleNode] (c) {}
                child {node[squareNode] (f) {2}}
                child {node[squareNode] (g) {1}}
            };

        % Labels for alpha and beta
        \node[right=0.7cm, align=left] at (root) {$\alpha = -\infty$ \\ $\beta = +\infty$};
        \node[right=0.7cm, align=left] at (b) {$\alpha = -\infty$ \\ $\textcolor{red}{\beta = 3}$};

        % Node labels
        \node[left=0.7cm] at (root) {\textbf{MAX}};
        \node[left=0.7cm] at (b) {\textbf{MIN}};
        \node[left=0.7cm] at (d) {\textbf{MAX}};

        % Edges
        \draw[-, draw=red] (root) -- (b);
        \draw[-] (root) -- (c);
        \draw[-, draw=red] (d) -- (b);
        \draw[-] (b) -- (e);
        \draw[-] (c) -- (f);
        \draw[-] (c) -- (g);
    \end{tikzpicture}

    \hspace{3em}

    \centering
    \begin{tikzpicture}[
        level distance=1.5cm,
        level 1/.style={sibling distance=4cm},
        level 2/.style={sibling distance=2cm},
        circleNode/.style={circle, draw, minimum size=1cm, inner sep=0pt},
        squareNode/.style={rectangle, draw, minimum size=1cm, inner sep=0pt}
    ]
        % Root node
        \node[squareNode] (root) {}
            child {node[circleNode, draw=red] (b) {\textcolor{red}{3}}
                child {node[squareNode] (d) {3}}
                child {node[squareNode] (e) {5}}
            }
            child {node[circleNode] (c) {}
                child {node[squareNode] (f) {2}}
                child {node[squareNode] (g) {1}}
            };

        % Labels for alpha and beta
        \node[right=0.7cm, align=left] at (root) {$\textcolor{red}{\alpha = 3}$ \\ $\beta = +\infty$};
        \node[right=0.7cm, align=left] at (b) {$\alpha = -\infty$ \\ $\beta = 3$};

        % Node labels
        \node[left=0.7cm] at (root) {\textbf{MAX}};
        \node[left=0.7cm] at (b) {\textbf{MIN}};
        \node[left=0.7cm] at (d) {\textbf{MAX}};

        % Edges
        \draw[-, draw=red] (root) -- (b);
        \draw[-] (root) -- (c);
        \draw[-, draw=red] (d) -- (b);
        \draw[-, draw=red] (b) -- (e);
        \draw[-] (c) -- (f);
        \draw[-] (c) -- (g);
    \end{tikzpicture}

    \hspace{3em}
    
    \centering
    \begin{tikzpicture}[
        level distance=1.5cm,
        level 1/.style={sibling distance=4cm},
        level 2/.style={sibling distance=2cm},
        circleNode/.style={circle, draw, minimum size=1cm, inner sep=0pt},
        squareNode/.style={rectangle, draw, minimum size=1cm, inner sep=0pt}
    ]
        % Root node
        \node[squareNode] (root) {}
            child {node[circleNode] (b) {3}
                child {node[squareNode] (d) {3}}
                child {node[squareNode] (e) {5}}
            }
            child {node[circleNode, draw=red] (c) {\textcolor{red}{2}}
                child {node[squareNode] (f) {2}}
                child {node[squareNode, dashed, gray] (g) {1}}
            };

        % Labels for alpha and beta
        \node[right=0.7cm, align=left] at (root) {$\alpha = 3$ \\ $\beta = +\infty$};
        \node[right=0.7cm, align=left] at (b) {$\alpha = -\infty$ \\ $\beta = 3$};
        \node[right=0.7cm, align=left] at (c) {$\alpha = 3$ \\ $\textcolor{red}{\beta = 2}$};

        % Node labels
        \node[left=0.7cm] at (root) {\textbf{MAX}};
        \node[left=0.7cm] at (b) {\textbf{MIN}};
        \node[left=0.7cm] at (d) {\textbf{MAX}};

        % Edges
        \draw[-] (b) -- (root);
        \draw[-, draw=red] (root) -- (c);
        \draw[-] (d) -- (b);
        \draw[-] (b) -- (e);
        \draw[-, draw=red] (c) -- (f);
        \draw[-, draw=gray, dashed] (c) -- (g);
    \end{tikzpicture}

    \hspace{3em}

    \centering
    \begin{tikzpicture}[
        level distance=1.5cm,
        level 1/.style={sibling distance=4cm},
        level 2/.style={sibling distance=2cm},
        circleNode/.style={circle, draw, minimum size=1cm, inner sep=0pt},
        squareNode/.style={rectangle, draw, minimum size=1cm, inner sep=0pt}
    ]
        % Root node
        \node[squareNode] (root) {3}
            child {node[circleNode] (b) {3}
                child {node[squareNode] (d) {3}}
                child {node[squareNode] (e) {5}}
            }
            child {node[circleNode] (c) {2}
                child {node[squareNode] (f) {2}}
                child {node[squareNode, dashed, gray] (g) {1}}
            };

        % Labels for alpha and beta
        \node[right=0.7cm, align=left] at (root) {$\alpha = 3$ \\ $\beta = +\infty$};
        \node[right=0.7cm, align=left] at (b) {$\alpha = -\infty$ \\ $\beta = 3$};
        \node[right=0.7cm, align=left] at (c) {$\alpha = 3$ \\ $\beta = 2$};

        % Node labels
        \node[left=0.7cm] at (root) {\textbf{MAX}};
        \node[left=0.7cm] at (b) {\textbf{MIN}};
        \node[left=0.7cm] at (d) {\textbf{MAX}};

        % Edges
        \draw[-, draw=red] (b) -- (root);
        \draw[-] (root) -- (c);
        \draw[-, draw=red] (d) -- (b);
        \draw[-] (b) -- (e);
        \draw[-] (f) -- (c);
        \draw[-, draw=gray, dashed] (c) -- (g);
    \end{tikzpicture}

    \caption{Example of alpha-beta pruning with $\alpha$ and $\beta$ values.}
    \label{fig:alpha-beta-pruning-with-alpha-beta-values}
\end{figure}

\subsubsection{Alpha-Beta Enhancements}

The alpha-beta algorithm has been further improved over time with various enhancements to increase the overall efficiency. Some of these are: Transposition Tables, Iterative Deepening, Aspiration Windows, Quiescence Search, Move Ordering\dots

\vspace{1em}

Take into consideration that many positions can be reached in different ways. This is formally known as \textbf{transpositions\footnote{\url{https://www.chessprogramming.org/Transposition}}}. Just like in dynamic programming\footnote{\url{https://en.wikipedia.org/wiki/Dynamic_programming}}, the evaluations of different positions are stored in a structure, the \textbf{transposition tables}, to avoid repeating the process of searching and evaluating, which improves efficiency. Take this following example:

\begin{figure}[H]
    \centering
    \begin{minipage}{0.6\textwidth}
        \centering
        \newchessgame
        \chessboard[
            setfen=rnbqkb1r/ppp2ppp/5n2/3p4/3P4/5N2/PPP2PPP/RNBQKB1R w KQkq - 0 1
        ]
    \end{minipage}
    \hspace{1em}
    \begin{minipage}{0.35\textwidth}
        \centering
        \textbf{French Defense:}\\
        1. e4 e6 2. d4 d5 3. exd5 exd5 4. Nf3 Nf6
        \vspace{1em}\\
        \textbf{Petrov Defense:}\\
        1. e4 e5 2. Nf3 Nf6 3. Nxe5 d6 4. Nf3 Nxe4 5. d3 Nf6 6. d4 d5
    \end{minipage}
    \caption{Example of transposition.}
    \label{fig:example-transposition}
\end{figure}

Both games reach the same position, although they involve a different number of moves.

\vspace{1em}

In order to store these different positions and access them in a map or dictionary structure, there is a need for a unique and efficient way to index positions: \textbf{Zobrist hashing}. Zobrist hashing maps a large number of possible positions to a fixed-size hash value, which can lead to collisions, as different positions may produce the same hash. To handle these collisions, storing additional information like the depth is used to verify the correctness of the entry. In some cases, overwriting the older or less relevant entries can be also useful.

\vspace{1em}

As it is mentioned in \url{https://www.chessprogramming.org/Search}, \textit{<<Depth-first algorithms are generally embedded inside an iterative deepening framework for time control and move ordering issues.>>}. \textbf{Iterative deepening} refers to the combination of DFS with limited depth searches. It performs successive searches by increasing the depth limit at each iteration, allowing you to obtain partial results quickly and improve accuracy over time.

\vspace{1em}

An important concept related to iterative deepening is the use of \textbf{aspiration windows}. Their main objective is to reduce the search space by narrowing the search bounds. In other words, by adjusting $alpha$ and $beta$ values in each iteration of the iterative deepening. If the value of the evaluation in the iteration falls outside this range or window, a re-search is performed with a wider window to ensure accuracy.

\vspace{1em}

Another critical concept is \textbf{quiescence search}. This is a search technique used to address the horizon effect at the end of the search. Simply stopping the search at a fixed or desired depth and evaluating the position can lead to inaccuracies, as critical tactical moves, such as captures, are often overlooked.

\begin{quotation}
    \textit{Consider the situation where the last move you consider is QxP. If you stop there and evaluate, you might think that you have won a pawn. But what if you were to search one move deeper and find that the next move is PxQ? You didn't win a pawn, you actually lost a queen. Hence the need to make sure that you are evaluating only quiescent (quiet) positions.}\footnote{\url{https://www.chessprogramming.org/Quiescence_Search}}
\end{quotation}

\vspace{1em}

Finally, alpha-beta algorithm could not perform well without \textbf{move ordering}\footnote{\url{https://www.chessprogramming.org/Move_Ordering}}. This is important to ensure that best moves are searched first and to reduce the search space of the game tree. Some of the techniques for move ordering are: Most Valuable victim - Least Valuable Aggressor (MVV-LVA) for captures and killer moves for non-captures. 

\paragraph{MVV-LVA} is a heuristic that prioritizes capturing moves by evaluating the value of the piece being captured (the victim) and the value of the piece performing the capture (the aggressor). The goal is to maximize the gain while minimizing the risk. The following example reflects this:

\begin{figure}[H]
    \centering
    \begin{minipage}{0.6\textwidth}
        \centering
        \newchessgame
        \chessboard[
            setfen=r2qr1k1/2p2pp1/p2p1n1p/npb1p2b/3PP3/2P2N1P/PPB2PP1/R1BQRNK1 b Qq - 0 1
        ]
    \end{minipage}
    \caption{Example of MVV-LVA.}
    \label{fig:example-mvv-lva}
\end{figure}

In this position, it is black's turn to play after white has moved $d4$, black has the option to capture the pawn on $d4$ with the pawn on $e5$ or with the bishop on $c5$. Between the two capturing movements, the best option is to take $d4$'s pawn with $e5$'s pawn because the pawn has less value than the bishop. Then, after $exd4$, white can re-capture with the pawn on $c3$ or the knight on $f3$. If black had taken the pawn with the bishop, white would have won a bishop for a pawn. This simple heuristic that orders what is best in capturing movements for each side can efficiently evaluate tactical exchanges and focus on moves that are more likely to yield a favorable outcome.

\paragraph{Killer moves} is a heuristic that considers moves that produced cutoffs or pruning while searching. When the engine encounters a similar position at the same depth later in the search, it will prioritize the last move that caused a cutoff, potentially leading to faster pruning.

\section{Evaluation functions}

\section{Strength Assessment}

%En el estado de la cuestión es donde aparecen gran parte de las referencias bibliográficas del trabajo. Una de las formas más cómodas de gestionar la bibliografía en {\LaTeX} es utilizando \textbf{bibtex}. Las entradas bibliográficas deben estar en un fichero con extensión \textit{.bib} (con esta plantilla se proporciona el fichero biblio.bib, donde están las entradas referenciadas más abajo). Cada entrada bibliográfica tiene una clave que permite referenciarla desde cualquier parte del texto con los siguiente comandos:

%\begin{itemize}
%\item Referencia bibliografica con cite: \cite{ldesc2e}
%\item Referencia bibliográfica con citep: \citep{notsoshort}
%\item Referencia bibliográfica con citet: \citet{latexAPrimer}
%\end{itemize}

%Es posible citar más de una fuente, como por ejemplo \citep{latexCompanion,LaTeXLamport,texKnuth}

%Después, \LaTeX se ocupa de rellenar la sección de bibliografía con las entradas \textbf{que hayan sido citadas} (es decir, no con todas las entradas que hay en el .bib, sino sólo con aquellas que se hayan citado en alguna parte del texto).

%Bibtex es un programa separado de latex, pdflatex o cualquier otra cosa que se use para compilar los .tex, de manera que para que se rellene correctamente la sección de bibliografía es necesario compilar primero el trabajo (a veces es necesario compilarlo dos veces), compilar después con bibtex, y volver a compilar otra vez el trabajo (de nuevo, puede ser necesario compilarlo dos veces). 
